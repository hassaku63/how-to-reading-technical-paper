# 実装志向・サーベイ志向で読む「実装系論文」効率読解ガイド（例: Dynamo）

実装を意識した読解は「再現に必要な仕様抽出」と「設計判断のトレードオフ理解」に分ける。ここではサーベイ目的と実装目的の二本立てで手順とチートシートを提示する。

## 1) 共通の初動（10–15分）
- 問題/要件: 機能要件（何を実現）と非機能要件（可用性/レイテンシ/スループット/コスト）。
- 敵対/故障モデル: 障害/分断/不一致/遅延の扱い。
- コア貢献: 既存との差分1–2行（例: Dynamoなら可用性優先のAP設計＋ベクタ時計等）。
- 主要機構一覧: コンポーネント名だけを列挙して地図化。

## 2) サーベイ目的の読み方（25–45分）
- 設計原則の抽出: 何を優先し何を犠牲にしたか（CAP/整合性モデル/一貫性レベル）。
- 変化点と一般化: 手法を抽象化して他分野へ転用できる形に再表現。
- 評価の妥当性: データ/負荷/故障注入/ベースライン/メトリクス/アブレーションの有無。
- 位置づけ: 同時代/後続の代表手法と差分（系譜マップを1枚）。

## 3) 実装者向け読解（60–120分）
- 仕様化メモ（最小実装に必要な断片）
  - API面: クライアント→ノードの操作（PUT/GET/DELETE）、コンシステントハッシュのルーティング。
  - データ配置: リング/パーティション、レプリカ数N、ノード参加/離脱。
  - 整合性制御: クォーラム（R/W）, 論理時計（ベクタ時計）、コンフリクト解決（LWW/アプリ解決）。
  - 耐障害化: ヒント付きハンドオフ、リードリペア、アンチエントロピー（Merkle Tree）。
  - フェイル検出/メンバーシップ: Gossip/心拍、障害判定閾値。
  - 運用: 監視メトリクス（p50/p95遅延、可用性、データ収束時間）。
- 実装手順（MVP→拡張）
  1) 単ノードKVS → 2) 一貫性ハッシュ＋レプリケーション → 3) クォーラムR/W → 4) 故障時のヒント付きハンドオフ → 5) リードリペア/アンチエントロピー → 6) メンバーシップ/Gossip。
- テスト戦略
  - 機能: PUT/GET整合、R/W閾値、衝突解決の帰結。
  - 性能: スループット/レイテンシ（p50/p95/p99）、N/R/Wでのトレードオフ。
  - 障害注入: ノード停止/遅延/ネットワーク分断、再参加時の収束確認。
  - プロパティベース: 片方向収束、可達性、データ損失なし、イベントual収束。
- 検証用メトリクス
  - 可用性（エラー率/成功率）、一貫性観測（read-your-writes逸脱率）、リペア時間、データ転送量。

## 4) Dynamo系の要点チートシート
- データ配置: コンシステントハッシュリング、パーティション、仮想ノードで負荷均衡。
- 可用性優先: AP寄り。N,R,Wの調整で読み/書きの整合性レベルを選択。
- 衝突検出/解決: ベクタ時計で因果関係を管理、解決はLWWまたはアプリロジック。
- 故障時の動作: Hinted Handoffで一時退避、Read RepairとMerkle Treeで整合性回復。
- メンバーシップ/Gossip: 定期的にリング情報を交換、部分的知識からの収束。

## 5) サンプルMVP設計（擬似コード/構成）
- モジュール構成
  - `HashRing`: 一貫性ハッシュ・ノード追加削除・キー→ノード解決
  - `ReplicaSet`: N, R, Wのポリシー、クォーラム算出
  - `Version`: ベクタ時計の加算/比較/縮約
  - `Storage`: ローカルKVS（LSM/Log-structuredやシンプルMapで可）
  - `Gossip`: メンバー情報交換（後回し可）
  - `Repair`: Read Repair / Merkle Sync
  - `HintedHandoff`: 代行保持/再送
- コア処理（概略）
  - PUT(k,v): ルーティング→レプリカ集合へ送信→W応答で成功→未達はヒント退避
  - GET(k): レプリカRから取得→ベクタ比較→矛盾あれば解決しRead Repair

## 6) 読解・実装のためのAIプロンプト例
- 仕様抽出: 「API/データ配置/整合性/耐障害/メンバーシップを箇条書きで抽出して。」
- テスト設計: 「N,R,Wと故障注入のテストケースを表形式で。」
- 擬似コード化: 「PUT/GET/ベクタ時計更新の擬似コードを出力。」
- リスク洗い出し: 「データ収束が破れるケースと対策を列挙。」

## 7) つまずきポイント/アンチパターン
- R/Wの意味を取り違える（R+W>Nで強整合“風”でも遅延や障害で破綻）。
- ベクタ時計の縮約/世代管理を放置（メタデータ肥大）。
- Merkle木の粒度/更新頻度設計を怠る（転送爆発）。
- Gossipの収束性に依存しすぎ、監視や手動オペの逃げ道がない。

---
本ガイドは最小MVP→段階的拡張の順に読む/作る流れを前提に、仕様抽出と検証を短サイクルで回すことを意図している。

